import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { RootState } from '../store'; 
import { Book, BookState } from '../../types/book'; 

const initialState: BookState = {
  books: [],
  loading: false,
  error: null,
};

// Async thunk to fetch all books
export const fetchBooks = createAsyncThunk('books/fetchBooks', async () => {
  try {
    const response = await fetch('http://localhost:3001/books');
    if (!response.ok) {
      throw new Error('Failed to fetch books');
    }
    const data: Book[] = await response.json();
    return data;
  } catch (error) {
    throw new Error((error as Error).message);
  }
});

// Async thunk to add a new book
export const addBook = createAsyncThunk(
  'books/addBook',
  async (newBook: Book, { rejectWithValue }) => {
    try {
      const response = await fetch('http://localhost:3001/books', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ ...newBook, id: String(newBook.id) }),
      });

      if (!response.ok) {
        throw new Error('Failed to add book');
      }

      const data: Book = await response.json();
      return data;
    } catch (error) {
      console.error('Error adding book:', (error as Error).message);
      return rejectWithValue((error as Error).message);
    }
  }
);

// Async thunk to delete a book
export const deleteBook = createAsyncThunk(
  'books/deleteBook',
  async (bookId: number, { rejectWithValue }) => {
    try {
      const response = await fetch(`http://localhost:3001/books/${String(bookId)}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        if (response.status === 404) {
          throw new Error('Book not found');
        } else {
          throw new Error('Failed to delete book');
        }
      }

      return bookId;
    } catch (error) {
      console.error('Error deleting book:', (error as Error).message);
      return rejectWithValue((error as Error).message);
    }
  }
);

// Async thunk to edit a book
export const editBook = createAsyncThunk(
  'books/editBook',
  async (updatedBook: Book, { rejectWithValue }) => {
    try {
      const response = await fetch(`http://localhost:3001/books/${updatedBook.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updatedBook),
      });

      if (!response.ok) {
        throw new Error('Failed to edit book');
      }

      const data: Book = await response.json();
      return data;
    } catch (error) {
      console.error('Error editing book:', (error as Error).message);
      return rejectWithValue((error as Error).message);
    }
  }
);

// Creating the bookSlice using createSlice from Redux Toolkit
const bookSlice = createSlice({
  name: 'books',
  initialState,
  reducers: {}, // No additional reducers defined in this slice
  extraReducers: builder => {
    // Reducers for handling actions generated by async thunks
    builder
      .addCase(fetchBooks.pending, state => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchBooks.fulfilled, (state, action: PayloadAction<Book[]>) => {
        state.books = action.payload;
        state.loading = false;
      })
      .addCase(fetchBooks.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to fetch books';
      })
      .addCase(addBook.pending, state => {
        state.loading = true;
        state.error = null;
      })
      .addCase(addBook.fulfilled, (state, action: PayloadAction<Book>) => {
        state.books.push(action.payload); // Ensure immutability when updating state.books
        state.loading = false;
      })
      .addCase(addBook.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string || 'Failed to add book';
      })
      .addCase(deleteBook.pending, state => {
        state.loading = true;
        state.error = null;
      })
      .addCase(deleteBook.fulfilled, (state, action: PayloadAction<number>) => {
        state.books = state.books.filter(book => book.id !== action.payload); // Ensure immutability
        state.loading = false;
      })
      .addCase(deleteBook.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string || 'Failed to delete book';
      })
      .addCase(editBook.pending, state => {
        state.loading = true;
        state.error = null;
      })
      .addCase(editBook.fulfilled, (state, action: PayloadAction<Book>) => {
        const index = state.books.findIndex(book => book.id === action.payload.id);
        if (index !== -1) {
          state.books[index] = action.payload; // Ensure immutability
        }
        state.loading = false;
      })
      .addCase(editBook.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string || 'Failed to edit book';
      });
  },
});

// Exporting reducer generated by createSlice
export default bookSlice.reducer;

// Exporting selectors for accessing specific parts of the state
export const selectBooks = (state: RootState) => state.books.books;
export const selectLoading = (state: RootState) => state.books.loading;
export const selectError = (state: RootState) => state.books.error;
